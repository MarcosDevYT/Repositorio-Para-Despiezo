
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck 
/*
 * This file exports the `KitProduct` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model KitProduct
 * 
 */
export type KitProductModel = runtime.Types.Result.DefaultSelection<Prisma.$KitProductPayload>

export type AggregateKitProduct = {
  _count: KitProductCountAggregateOutputType | null
  _min: KitProductMinAggregateOutputType | null
  _max: KitProductMaxAggregateOutputType | null
}

export type KitProductMinAggregateOutputType = {
  id: string | null
  kitId: string | null
  productId: string | null
}

export type KitProductMaxAggregateOutputType = {
  id: string | null
  kitId: string | null
  productId: string | null
}

export type KitProductCountAggregateOutputType = {
  id: number
  kitId: number
  productId: number
  _all: number
}


export type KitProductMinAggregateInputType = {
  id?: true
  kitId?: true
  productId?: true
}

export type KitProductMaxAggregateInputType = {
  id?: true
  kitId?: true
  productId?: true
}

export type KitProductCountAggregateInputType = {
  id?: true
  kitId?: true
  productId?: true
  _all?: true
}

export type KitProductAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which KitProduct to aggregate.
   */
  where?: Prisma.KitProductWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of KitProducts to fetch.
   */
  orderBy?: Prisma.KitProductOrderByWithRelationInput | Prisma.KitProductOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.KitProductWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` KitProducts from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` KitProducts.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned KitProducts
  **/
  _count?: true | KitProductCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: KitProductMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: KitProductMaxAggregateInputType
}

export type GetKitProductAggregateType<T extends KitProductAggregateArgs> = {
      [P in keyof T & keyof AggregateKitProduct]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateKitProduct[P]>
    : Prisma.GetScalarType<T[P], AggregateKitProduct[P]>
}




export type KitProductGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.KitProductWhereInput
  orderBy?: Prisma.KitProductOrderByWithAggregationInput | Prisma.KitProductOrderByWithAggregationInput[]
  by: Prisma.KitProductScalarFieldEnum[] | Prisma.KitProductScalarFieldEnum
  having?: Prisma.KitProductScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: KitProductCountAggregateInputType | true
  _min?: KitProductMinAggregateInputType
  _max?: KitProductMaxAggregateInputType
}

export type KitProductGroupByOutputType = {
  id: string
  kitId: string
  productId: string
  _count: KitProductCountAggregateOutputType | null
  _min: KitProductMinAggregateOutputType | null
  _max: KitProductMaxAggregateOutputType | null
}

type GetKitProductGroupByPayload<T extends KitProductGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<KitProductGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof KitProductGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], KitProductGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], KitProductGroupByOutputType[P]>
      }
    >
  >



export type KitProductWhereInput = {
  AND?: Prisma.KitProductWhereInput | Prisma.KitProductWhereInput[]
  OR?: Prisma.KitProductWhereInput[]
  NOT?: Prisma.KitProductWhereInput | Prisma.KitProductWhereInput[]
  id?: Prisma.StringFilter<"KitProduct"> | string
  kitId?: Prisma.StringFilter<"KitProduct"> | string
  productId?: Prisma.StringFilter<"KitProduct"> | string
  kit?: Prisma.XOR<Prisma.KitScalarRelationFilter, Prisma.KitWhereInput>
  product?: Prisma.XOR<Prisma.ProductScalarRelationFilter, Prisma.ProductWhereInput>
}

export type KitProductOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  kitId?: Prisma.SortOrder
  productId?: Prisma.SortOrder
  kit?: Prisma.KitOrderByWithRelationInput
  product?: Prisma.ProductOrderByWithRelationInput
}

export type KitProductWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.KitProductWhereInput | Prisma.KitProductWhereInput[]
  OR?: Prisma.KitProductWhereInput[]
  NOT?: Prisma.KitProductWhereInput | Prisma.KitProductWhereInput[]
  kitId?: Prisma.StringFilter<"KitProduct"> | string
  productId?: Prisma.StringFilter<"KitProduct"> | string
  kit?: Prisma.XOR<Prisma.KitScalarRelationFilter, Prisma.KitWhereInput>
  product?: Prisma.XOR<Prisma.ProductScalarRelationFilter, Prisma.ProductWhereInput>
}, "id">

export type KitProductOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  kitId?: Prisma.SortOrder
  productId?: Prisma.SortOrder
  _count?: Prisma.KitProductCountOrderByAggregateInput
  _max?: Prisma.KitProductMaxOrderByAggregateInput
  _min?: Prisma.KitProductMinOrderByAggregateInput
}

export type KitProductScalarWhereWithAggregatesInput = {
  AND?: Prisma.KitProductScalarWhereWithAggregatesInput | Prisma.KitProductScalarWhereWithAggregatesInput[]
  OR?: Prisma.KitProductScalarWhereWithAggregatesInput[]
  NOT?: Prisma.KitProductScalarWhereWithAggregatesInput | Prisma.KitProductScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"KitProduct"> | string
  kitId?: Prisma.StringWithAggregatesFilter<"KitProduct"> | string
  productId?: Prisma.StringWithAggregatesFilter<"KitProduct"> | string
}

export type KitProductCreateInput = {
  id?: string
  kit: Prisma.KitCreateNestedOneWithoutProductsInput
  product: Prisma.ProductCreateNestedOneWithoutKitsInput
}

export type KitProductUncheckedCreateInput = {
  id?: string
  kitId: string
  productId: string
}

export type KitProductUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  kit?: Prisma.KitUpdateOneRequiredWithoutProductsNestedInput
  product?: Prisma.ProductUpdateOneRequiredWithoutKitsNestedInput
}

export type KitProductUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  kitId?: Prisma.StringFieldUpdateOperationsInput | string
  productId?: Prisma.StringFieldUpdateOperationsInput | string
}

export type KitProductCreateManyInput = {
  id?: string
  kitId: string
  productId: string
}

export type KitProductUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
}

export type KitProductUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  kitId?: Prisma.StringFieldUpdateOperationsInput | string
  productId?: Prisma.StringFieldUpdateOperationsInput | string
}

export type KitProductListRelationFilter = {
  every?: Prisma.KitProductWhereInput
  some?: Prisma.KitProductWhereInput
  none?: Prisma.KitProductWhereInput
}

export type KitProductOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type KitProductCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  kitId?: Prisma.SortOrder
  productId?: Prisma.SortOrder
}

export type KitProductMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  kitId?: Prisma.SortOrder
  productId?: Prisma.SortOrder
}

export type KitProductMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  kitId?: Prisma.SortOrder
  productId?: Prisma.SortOrder
}

export type KitProductCreateNestedManyWithoutProductInput = {
  create?: Prisma.XOR<Prisma.KitProductCreateWithoutProductInput, Prisma.KitProductUncheckedCreateWithoutProductInput> | Prisma.KitProductCreateWithoutProductInput[] | Prisma.KitProductUncheckedCreateWithoutProductInput[]
  connectOrCreate?: Prisma.KitProductCreateOrConnectWithoutProductInput | Prisma.KitProductCreateOrConnectWithoutProductInput[]
  createMany?: Prisma.KitProductCreateManyProductInputEnvelope
  connect?: Prisma.KitProductWhereUniqueInput | Prisma.KitProductWhereUniqueInput[]
}

export type KitProductUncheckedCreateNestedManyWithoutProductInput = {
  create?: Prisma.XOR<Prisma.KitProductCreateWithoutProductInput, Prisma.KitProductUncheckedCreateWithoutProductInput> | Prisma.KitProductCreateWithoutProductInput[] | Prisma.KitProductUncheckedCreateWithoutProductInput[]
  connectOrCreate?: Prisma.KitProductCreateOrConnectWithoutProductInput | Prisma.KitProductCreateOrConnectWithoutProductInput[]
  createMany?: Prisma.KitProductCreateManyProductInputEnvelope
  connect?: Prisma.KitProductWhereUniqueInput | Prisma.KitProductWhereUniqueInput[]
}

export type KitProductUpdateManyWithoutProductNestedInput = {
  create?: Prisma.XOR<Prisma.KitProductCreateWithoutProductInput, Prisma.KitProductUncheckedCreateWithoutProductInput> | Prisma.KitProductCreateWithoutProductInput[] | Prisma.KitProductUncheckedCreateWithoutProductInput[]
  connectOrCreate?: Prisma.KitProductCreateOrConnectWithoutProductInput | Prisma.KitProductCreateOrConnectWithoutProductInput[]
  upsert?: Prisma.KitProductUpsertWithWhereUniqueWithoutProductInput | Prisma.KitProductUpsertWithWhereUniqueWithoutProductInput[]
  createMany?: Prisma.KitProductCreateManyProductInputEnvelope
  set?: Prisma.KitProductWhereUniqueInput | Prisma.KitProductWhereUniqueInput[]
  disconnect?: Prisma.KitProductWhereUniqueInput | Prisma.KitProductWhereUniqueInput[]
  delete?: Prisma.KitProductWhereUniqueInput | Prisma.KitProductWhereUniqueInput[]
  connect?: Prisma.KitProductWhereUniqueInput | Prisma.KitProductWhereUniqueInput[]
  update?: Prisma.KitProductUpdateWithWhereUniqueWithoutProductInput | Prisma.KitProductUpdateWithWhereUniqueWithoutProductInput[]
  updateMany?: Prisma.KitProductUpdateManyWithWhereWithoutProductInput | Prisma.KitProductUpdateManyWithWhereWithoutProductInput[]
  deleteMany?: Prisma.KitProductScalarWhereInput | Prisma.KitProductScalarWhereInput[]
}

export type KitProductUncheckedUpdateManyWithoutProductNestedInput = {
  create?: Prisma.XOR<Prisma.KitProductCreateWithoutProductInput, Prisma.KitProductUncheckedCreateWithoutProductInput> | Prisma.KitProductCreateWithoutProductInput[] | Prisma.KitProductUncheckedCreateWithoutProductInput[]
  connectOrCreate?: Prisma.KitProductCreateOrConnectWithoutProductInput | Prisma.KitProductCreateOrConnectWithoutProductInput[]
  upsert?: Prisma.KitProductUpsertWithWhereUniqueWithoutProductInput | Prisma.KitProductUpsertWithWhereUniqueWithoutProductInput[]
  createMany?: Prisma.KitProductCreateManyProductInputEnvelope
  set?: Prisma.KitProductWhereUniqueInput | Prisma.KitProductWhereUniqueInput[]
  disconnect?: Prisma.KitProductWhereUniqueInput | Prisma.KitProductWhereUniqueInput[]
  delete?: Prisma.KitProductWhereUniqueInput | Prisma.KitProductWhereUniqueInput[]
  connect?: Prisma.KitProductWhereUniqueInput | Prisma.KitProductWhereUniqueInput[]
  update?: Prisma.KitProductUpdateWithWhereUniqueWithoutProductInput | Prisma.KitProductUpdateWithWhereUniqueWithoutProductInput[]
  updateMany?: Prisma.KitProductUpdateManyWithWhereWithoutProductInput | Prisma.KitProductUpdateManyWithWhereWithoutProductInput[]
  deleteMany?: Prisma.KitProductScalarWhereInput | Prisma.KitProductScalarWhereInput[]
}

export type KitProductCreateNestedManyWithoutKitInput = {
  create?: Prisma.XOR<Prisma.KitProductCreateWithoutKitInput, Prisma.KitProductUncheckedCreateWithoutKitInput> | Prisma.KitProductCreateWithoutKitInput[] | Prisma.KitProductUncheckedCreateWithoutKitInput[]
  connectOrCreate?: Prisma.KitProductCreateOrConnectWithoutKitInput | Prisma.KitProductCreateOrConnectWithoutKitInput[]
  createMany?: Prisma.KitProductCreateManyKitInputEnvelope
  connect?: Prisma.KitProductWhereUniqueInput | Prisma.KitProductWhereUniqueInput[]
}

export type KitProductUncheckedCreateNestedManyWithoutKitInput = {
  create?: Prisma.XOR<Prisma.KitProductCreateWithoutKitInput, Prisma.KitProductUncheckedCreateWithoutKitInput> | Prisma.KitProductCreateWithoutKitInput[] | Prisma.KitProductUncheckedCreateWithoutKitInput[]
  connectOrCreate?: Prisma.KitProductCreateOrConnectWithoutKitInput | Prisma.KitProductCreateOrConnectWithoutKitInput[]
  createMany?: Prisma.KitProductCreateManyKitInputEnvelope
  connect?: Prisma.KitProductWhereUniqueInput | Prisma.KitProductWhereUniqueInput[]
}

export type KitProductUpdateManyWithoutKitNestedInput = {
  create?: Prisma.XOR<Prisma.KitProductCreateWithoutKitInput, Prisma.KitProductUncheckedCreateWithoutKitInput> | Prisma.KitProductCreateWithoutKitInput[] | Prisma.KitProductUncheckedCreateWithoutKitInput[]
  connectOrCreate?: Prisma.KitProductCreateOrConnectWithoutKitInput | Prisma.KitProductCreateOrConnectWithoutKitInput[]
  upsert?: Prisma.KitProductUpsertWithWhereUniqueWithoutKitInput | Prisma.KitProductUpsertWithWhereUniqueWithoutKitInput[]
  createMany?: Prisma.KitProductCreateManyKitInputEnvelope
  set?: Prisma.KitProductWhereUniqueInput | Prisma.KitProductWhereUniqueInput[]
  disconnect?: Prisma.KitProductWhereUniqueInput | Prisma.KitProductWhereUniqueInput[]
  delete?: Prisma.KitProductWhereUniqueInput | Prisma.KitProductWhereUniqueInput[]
  connect?: Prisma.KitProductWhereUniqueInput | Prisma.KitProductWhereUniqueInput[]
  update?: Prisma.KitProductUpdateWithWhereUniqueWithoutKitInput | Prisma.KitProductUpdateWithWhereUniqueWithoutKitInput[]
  updateMany?: Prisma.KitProductUpdateManyWithWhereWithoutKitInput | Prisma.KitProductUpdateManyWithWhereWithoutKitInput[]
  deleteMany?: Prisma.KitProductScalarWhereInput | Prisma.KitProductScalarWhereInput[]
}

export type KitProductUncheckedUpdateManyWithoutKitNestedInput = {
  create?: Prisma.XOR<Prisma.KitProductCreateWithoutKitInput, Prisma.KitProductUncheckedCreateWithoutKitInput> | Prisma.KitProductCreateWithoutKitInput[] | Prisma.KitProductUncheckedCreateWithoutKitInput[]
  connectOrCreate?: Prisma.KitProductCreateOrConnectWithoutKitInput | Prisma.KitProductCreateOrConnectWithoutKitInput[]
  upsert?: Prisma.KitProductUpsertWithWhereUniqueWithoutKitInput | Prisma.KitProductUpsertWithWhereUniqueWithoutKitInput[]
  createMany?: Prisma.KitProductCreateManyKitInputEnvelope
  set?: Prisma.KitProductWhereUniqueInput | Prisma.KitProductWhereUniqueInput[]
  disconnect?: Prisma.KitProductWhereUniqueInput | Prisma.KitProductWhereUniqueInput[]
  delete?: Prisma.KitProductWhereUniqueInput | Prisma.KitProductWhereUniqueInput[]
  connect?: Prisma.KitProductWhereUniqueInput | Prisma.KitProductWhereUniqueInput[]
  update?: Prisma.KitProductUpdateWithWhereUniqueWithoutKitInput | Prisma.KitProductUpdateWithWhereUniqueWithoutKitInput[]
  updateMany?: Prisma.KitProductUpdateManyWithWhereWithoutKitInput | Prisma.KitProductUpdateManyWithWhereWithoutKitInput[]
  deleteMany?: Prisma.KitProductScalarWhereInput | Prisma.KitProductScalarWhereInput[]
}

export type KitProductCreateWithoutProductInput = {
  id?: string
  kit: Prisma.KitCreateNestedOneWithoutProductsInput
}

export type KitProductUncheckedCreateWithoutProductInput = {
  id?: string
  kitId: string
}

export type KitProductCreateOrConnectWithoutProductInput = {
  where: Prisma.KitProductWhereUniqueInput
  create: Prisma.XOR<Prisma.KitProductCreateWithoutProductInput, Prisma.KitProductUncheckedCreateWithoutProductInput>
}

export type KitProductCreateManyProductInputEnvelope = {
  data: Prisma.KitProductCreateManyProductInput | Prisma.KitProductCreateManyProductInput[]
  skipDuplicates?: boolean
}

export type KitProductUpsertWithWhereUniqueWithoutProductInput = {
  where: Prisma.KitProductWhereUniqueInput
  update: Prisma.XOR<Prisma.KitProductUpdateWithoutProductInput, Prisma.KitProductUncheckedUpdateWithoutProductInput>
  create: Prisma.XOR<Prisma.KitProductCreateWithoutProductInput, Prisma.KitProductUncheckedCreateWithoutProductInput>
}

export type KitProductUpdateWithWhereUniqueWithoutProductInput = {
  where: Prisma.KitProductWhereUniqueInput
  data: Prisma.XOR<Prisma.KitProductUpdateWithoutProductInput, Prisma.KitProductUncheckedUpdateWithoutProductInput>
}

export type KitProductUpdateManyWithWhereWithoutProductInput = {
  where: Prisma.KitProductScalarWhereInput
  data: Prisma.XOR<Prisma.KitProductUpdateManyMutationInput, Prisma.KitProductUncheckedUpdateManyWithoutProductInput>
}

export type KitProductScalarWhereInput = {
  AND?: Prisma.KitProductScalarWhereInput | Prisma.KitProductScalarWhereInput[]
  OR?: Prisma.KitProductScalarWhereInput[]
  NOT?: Prisma.KitProductScalarWhereInput | Prisma.KitProductScalarWhereInput[]
  id?: Prisma.StringFilter<"KitProduct"> | string
  kitId?: Prisma.StringFilter<"KitProduct"> | string
  productId?: Prisma.StringFilter<"KitProduct"> | string
}

export type KitProductCreateWithoutKitInput = {
  id?: string
  product: Prisma.ProductCreateNestedOneWithoutKitsInput
}

export type KitProductUncheckedCreateWithoutKitInput = {
  id?: string
  productId: string
}

export type KitProductCreateOrConnectWithoutKitInput = {
  where: Prisma.KitProductWhereUniqueInput
  create: Prisma.XOR<Prisma.KitProductCreateWithoutKitInput, Prisma.KitProductUncheckedCreateWithoutKitInput>
}

export type KitProductCreateManyKitInputEnvelope = {
  data: Prisma.KitProductCreateManyKitInput | Prisma.KitProductCreateManyKitInput[]
  skipDuplicates?: boolean
}

export type KitProductUpsertWithWhereUniqueWithoutKitInput = {
  where: Prisma.KitProductWhereUniqueInput
  update: Prisma.XOR<Prisma.KitProductUpdateWithoutKitInput, Prisma.KitProductUncheckedUpdateWithoutKitInput>
  create: Prisma.XOR<Prisma.KitProductCreateWithoutKitInput, Prisma.KitProductUncheckedCreateWithoutKitInput>
}

export type KitProductUpdateWithWhereUniqueWithoutKitInput = {
  where: Prisma.KitProductWhereUniqueInput
  data: Prisma.XOR<Prisma.KitProductUpdateWithoutKitInput, Prisma.KitProductUncheckedUpdateWithoutKitInput>
}

export type KitProductUpdateManyWithWhereWithoutKitInput = {
  where: Prisma.KitProductScalarWhereInput
  data: Prisma.XOR<Prisma.KitProductUpdateManyMutationInput, Prisma.KitProductUncheckedUpdateManyWithoutKitInput>
}

export type KitProductCreateManyProductInput = {
  id?: string
  kitId: string
}

export type KitProductUpdateWithoutProductInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  kit?: Prisma.KitUpdateOneRequiredWithoutProductsNestedInput
}

export type KitProductUncheckedUpdateWithoutProductInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  kitId?: Prisma.StringFieldUpdateOperationsInput | string
}

export type KitProductUncheckedUpdateManyWithoutProductInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  kitId?: Prisma.StringFieldUpdateOperationsInput | string
}

export type KitProductCreateManyKitInput = {
  id?: string
  productId: string
}

export type KitProductUpdateWithoutKitInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  product?: Prisma.ProductUpdateOneRequiredWithoutKitsNestedInput
}

export type KitProductUncheckedUpdateWithoutKitInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  productId?: Prisma.StringFieldUpdateOperationsInput | string
}

export type KitProductUncheckedUpdateManyWithoutKitInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  productId?: Prisma.StringFieldUpdateOperationsInput | string
}



export type KitProductSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  kitId?: boolean
  productId?: boolean
  kit?: boolean | Prisma.KitDefaultArgs<ExtArgs>
  product?: boolean | Prisma.ProductDefaultArgs<ExtArgs>
}, ExtArgs["result"]["kitProduct"]>

export type KitProductSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  kitId?: boolean
  productId?: boolean
  kit?: boolean | Prisma.KitDefaultArgs<ExtArgs>
  product?: boolean | Prisma.ProductDefaultArgs<ExtArgs>
}, ExtArgs["result"]["kitProduct"]>

export type KitProductSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  kitId?: boolean
  productId?: boolean
  kit?: boolean | Prisma.KitDefaultArgs<ExtArgs>
  product?: boolean | Prisma.ProductDefaultArgs<ExtArgs>
}, ExtArgs["result"]["kitProduct"]>

export type KitProductSelectScalar = {
  id?: boolean
  kitId?: boolean
  productId?: boolean
}

export type KitProductOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "kitId" | "productId", ExtArgs["result"]["kitProduct"]>
export type KitProductInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  kit?: boolean | Prisma.KitDefaultArgs<ExtArgs>
  product?: boolean | Prisma.ProductDefaultArgs<ExtArgs>
}
export type KitProductIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  kit?: boolean | Prisma.KitDefaultArgs<ExtArgs>
  product?: boolean | Prisma.ProductDefaultArgs<ExtArgs>
}
export type KitProductIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  kit?: boolean | Prisma.KitDefaultArgs<ExtArgs>
  product?: boolean | Prisma.ProductDefaultArgs<ExtArgs>
}

export type $KitProductPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "KitProduct"
  objects: {
    kit: Prisma.$KitPayload<ExtArgs>
    product: Prisma.$ProductPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    kitId: string
    productId: string
  }, ExtArgs["result"]["kitProduct"]>
  composites: {}
}

export type KitProductGetPayload<S extends boolean | null | undefined | KitProductDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$KitProductPayload, S>

export type KitProductCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<KitProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: KitProductCountAggregateInputType | true
  }

export interface KitProductDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KitProduct'], meta: { name: 'KitProduct' } }
  /**
   * Find zero or one KitProduct that matches the filter.
   * @param {KitProductFindUniqueArgs} args - Arguments to find a KitProduct
   * @example
   * // Get one KitProduct
   * const kitProduct = await prisma.kitProduct.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends KitProductFindUniqueArgs>(args: Prisma.SelectSubset<T, KitProductFindUniqueArgs<ExtArgs>>): Prisma.Prisma__KitProductClient<runtime.Types.Result.GetResult<Prisma.$KitProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one KitProduct that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {KitProductFindUniqueOrThrowArgs} args - Arguments to find a KitProduct
   * @example
   * // Get one KitProduct
   * const kitProduct = await prisma.kitProduct.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends KitProductFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, KitProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__KitProductClient<runtime.Types.Result.GetResult<Prisma.$KitProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first KitProduct that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {KitProductFindFirstArgs} args - Arguments to find a KitProduct
   * @example
   * // Get one KitProduct
   * const kitProduct = await prisma.kitProduct.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends KitProductFindFirstArgs>(args?: Prisma.SelectSubset<T, KitProductFindFirstArgs<ExtArgs>>): Prisma.Prisma__KitProductClient<runtime.Types.Result.GetResult<Prisma.$KitProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first KitProduct that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {KitProductFindFirstOrThrowArgs} args - Arguments to find a KitProduct
   * @example
   * // Get one KitProduct
   * const kitProduct = await prisma.kitProduct.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends KitProductFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, KitProductFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__KitProductClient<runtime.Types.Result.GetResult<Prisma.$KitProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more KitProducts that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {KitProductFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all KitProducts
   * const kitProducts = await prisma.kitProduct.findMany()
   * 
   * // Get first 10 KitProducts
   * const kitProducts = await prisma.kitProduct.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const kitProductWithIdOnly = await prisma.kitProduct.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends KitProductFindManyArgs>(args?: Prisma.SelectSubset<T, KitProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$KitProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a KitProduct.
   * @param {KitProductCreateArgs} args - Arguments to create a KitProduct.
   * @example
   * // Create one KitProduct
   * const KitProduct = await prisma.kitProduct.create({
   *   data: {
   *     // ... data to create a KitProduct
   *   }
   * })
   * 
   */
  create<T extends KitProductCreateArgs>(args: Prisma.SelectSubset<T, KitProductCreateArgs<ExtArgs>>): Prisma.Prisma__KitProductClient<runtime.Types.Result.GetResult<Prisma.$KitProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many KitProducts.
   * @param {KitProductCreateManyArgs} args - Arguments to create many KitProducts.
   * @example
   * // Create many KitProducts
   * const kitProduct = await prisma.kitProduct.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends KitProductCreateManyArgs>(args?: Prisma.SelectSubset<T, KitProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many KitProducts and returns the data saved in the database.
   * @param {KitProductCreateManyAndReturnArgs} args - Arguments to create many KitProducts.
   * @example
   * // Create many KitProducts
   * const kitProduct = await prisma.kitProduct.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many KitProducts and only return the `id`
   * const kitProductWithIdOnly = await prisma.kitProduct.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends KitProductCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, KitProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$KitProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a KitProduct.
   * @param {KitProductDeleteArgs} args - Arguments to delete one KitProduct.
   * @example
   * // Delete one KitProduct
   * const KitProduct = await prisma.kitProduct.delete({
   *   where: {
   *     // ... filter to delete one KitProduct
   *   }
   * })
   * 
   */
  delete<T extends KitProductDeleteArgs>(args: Prisma.SelectSubset<T, KitProductDeleteArgs<ExtArgs>>): Prisma.Prisma__KitProductClient<runtime.Types.Result.GetResult<Prisma.$KitProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one KitProduct.
   * @param {KitProductUpdateArgs} args - Arguments to update one KitProduct.
   * @example
   * // Update one KitProduct
   * const kitProduct = await prisma.kitProduct.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends KitProductUpdateArgs>(args: Prisma.SelectSubset<T, KitProductUpdateArgs<ExtArgs>>): Prisma.Prisma__KitProductClient<runtime.Types.Result.GetResult<Prisma.$KitProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more KitProducts.
   * @param {KitProductDeleteManyArgs} args - Arguments to filter KitProducts to delete.
   * @example
   * // Delete a few KitProducts
   * const { count } = await prisma.kitProduct.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends KitProductDeleteManyArgs>(args?: Prisma.SelectSubset<T, KitProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more KitProducts.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {KitProductUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many KitProducts
   * const kitProduct = await prisma.kitProduct.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends KitProductUpdateManyArgs>(args: Prisma.SelectSubset<T, KitProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more KitProducts and returns the data updated in the database.
   * @param {KitProductUpdateManyAndReturnArgs} args - Arguments to update many KitProducts.
   * @example
   * // Update many KitProducts
   * const kitProduct = await prisma.kitProduct.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more KitProducts and only return the `id`
   * const kitProductWithIdOnly = await prisma.kitProduct.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends KitProductUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, KitProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$KitProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one KitProduct.
   * @param {KitProductUpsertArgs} args - Arguments to update or create a KitProduct.
   * @example
   * // Update or create a KitProduct
   * const kitProduct = await prisma.kitProduct.upsert({
   *   create: {
   *     // ... data to create a KitProduct
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the KitProduct we want to update
   *   }
   * })
   */
  upsert<T extends KitProductUpsertArgs>(args: Prisma.SelectSubset<T, KitProductUpsertArgs<ExtArgs>>): Prisma.Prisma__KitProductClient<runtime.Types.Result.GetResult<Prisma.$KitProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of KitProducts.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {KitProductCountArgs} args - Arguments to filter KitProducts to count.
   * @example
   * // Count the number of KitProducts
   * const count = await prisma.kitProduct.count({
   *   where: {
   *     // ... the filter for the KitProducts we want to count
   *   }
   * })
  **/
  count<T extends KitProductCountArgs>(
    args?: Prisma.Subset<T, KitProductCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], KitProductCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a KitProduct.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {KitProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends KitProductAggregateArgs>(args: Prisma.Subset<T, KitProductAggregateArgs>): Prisma.PrismaPromise<GetKitProductAggregateType<T>>

  /**
   * Group by KitProduct.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {KitProductGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends KitProductGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: KitProductGroupByArgs['orderBy'] }
      : { orderBy?: KitProductGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, KitProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKitProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the KitProduct model
 */
readonly fields: KitProductFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for KitProduct.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__KitProductClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  kit<T extends Prisma.KitDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.KitDefaultArgs<ExtArgs>>): Prisma.Prisma__KitClient<runtime.Types.Result.GetResult<Prisma.$KitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  product<T extends Prisma.ProductDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ProductDefaultArgs<ExtArgs>>): Prisma.Prisma__ProductClient<runtime.Types.Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the KitProduct model
 */
export interface KitProductFieldRefs {
  readonly id: Prisma.FieldRef<"KitProduct", 'String'>
  readonly kitId: Prisma.FieldRef<"KitProduct", 'String'>
  readonly productId: Prisma.FieldRef<"KitProduct", 'String'>
}
    

// Custom InputTypes
/**
 * KitProduct findUnique
 */
export type KitProductFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the KitProduct
   */
  select?: Prisma.KitProductSelect<ExtArgs> | null
  /**
   * Omit specific fields from the KitProduct
   */
  omit?: Prisma.KitProductOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.KitProductInclude<ExtArgs> | null
  /**
   * Filter, which KitProduct to fetch.
   */
  where: Prisma.KitProductWhereUniqueInput
}

/**
 * KitProduct findUniqueOrThrow
 */
export type KitProductFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the KitProduct
   */
  select?: Prisma.KitProductSelect<ExtArgs> | null
  /**
   * Omit specific fields from the KitProduct
   */
  omit?: Prisma.KitProductOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.KitProductInclude<ExtArgs> | null
  /**
   * Filter, which KitProduct to fetch.
   */
  where: Prisma.KitProductWhereUniqueInput
}

/**
 * KitProduct findFirst
 */
export type KitProductFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the KitProduct
   */
  select?: Prisma.KitProductSelect<ExtArgs> | null
  /**
   * Omit specific fields from the KitProduct
   */
  omit?: Prisma.KitProductOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.KitProductInclude<ExtArgs> | null
  /**
   * Filter, which KitProduct to fetch.
   */
  where?: Prisma.KitProductWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of KitProducts to fetch.
   */
  orderBy?: Prisma.KitProductOrderByWithRelationInput | Prisma.KitProductOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for KitProducts.
   */
  cursor?: Prisma.KitProductWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` KitProducts from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` KitProducts.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of KitProducts.
   */
  distinct?: Prisma.KitProductScalarFieldEnum | Prisma.KitProductScalarFieldEnum[]
}

/**
 * KitProduct findFirstOrThrow
 */
export type KitProductFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the KitProduct
   */
  select?: Prisma.KitProductSelect<ExtArgs> | null
  /**
   * Omit specific fields from the KitProduct
   */
  omit?: Prisma.KitProductOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.KitProductInclude<ExtArgs> | null
  /**
   * Filter, which KitProduct to fetch.
   */
  where?: Prisma.KitProductWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of KitProducts to fetch.
   */
  orderBy?: Prisma.KitProductOrderByWithRelationInput | Prisma.KitProductOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for KitProducts.
   */
  cursor?: Prisma.KitProductWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` KitProducts from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` KitProducts.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of KitProducts.
   */
  distinct?: Prisma.KitProductScalarFieldEnum | Prisma.KitProductScalarFieldEnum[]
}

/**
 * KitProduct findMany
 */
export type KitProductFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the KitProduct
   */
  select?: Prisma.KitProductSelect<ExtArgs> | null
  /**
   * Omit specific fields from the KitProduct
   */
  omit?: Prisma.KitProductOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.KitProductInclude<ExtArgs> | null
  /**
   * Filter, which KitProducts to fetch.
   */
  where?: Prisma.KitProductWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of KitProducts to fetch.
   */
  orderBy?: Prisma.KitProductOrderByWithRelationInput | Prisma.KitProductOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing KitProducts.
   */
  cursor?: Prisma.KitProductWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` KitProducts from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` KitProducts.
   */
  skip?: number
  distinct?: Prisma.KitProductScalarFieldEnum | Prisma.KitProductScalarFieldEnum[]
}

/**
 * KitProduct create
 */
export type KitProductCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the KitProduct
   */
  select?: Prisma.KitProductSelect<ExtArgs> | null
  /**
   * Omit specific fields from the KitProduct
   */
  omit?: Prisma.KitProductOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.KitProductInclude<ExtArgs> | null
  /**
   * The data needed to create a KitProduct.
   */
  data: Prisma.XOR<Prisma.KitProductCreateInput, Prisma.KitProductUncheckedCreateInput>
}

/**
 * KitProduct createMany
 */
export type KitProductCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many KitProducts.
   */
  data: Prisma.KitProductCreateManyInput | Prisma.KitProductCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * KitProduct createManyAndReturn
 */
export type KitProductCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the KitProduct
   */
  select?: Prisma.KitProductSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the KitProduct
   */
  omit?: Prisma.KitProductOmit<ExtArgs> | null
  /**
   * The data used to create many KitProducts.
   */
  data: Prisma.KitProductCreateManyInput | Prisma.KitProductCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.KitProductIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * KitProduct update
 */
export type KitProductUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the KitProduct
   */
  select?: Prisma.KitProductSelect<ExtArgs> | null
  /**
   * Omit specific fields from the KitProduct
   */
  omit?: Prisma.KitProductOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.KitProductInclude<ExtArgs> | null
  /**
   * The data needed to update a KitProduct.
   */
  data: Prisma.XOR<Prisma.KitProductUpdateInput, Prisma.KitProductUncheckedUpdateInput>
  /**
   * Choose, which KitProduct to update.
   */
  where: Prisma.KitProductWhereUniqueInput
}

/**
 * KitProduct updateMany
 */
export type KitProductUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update KitProducts.
   */
  data: Prisma.XOR<Prisma.KitProductUpdateManyMutationInput, Prisma.KitProductUncheckedUpdateManyInput>
  /**
   * Filter which KitProducts to update
   */
  where?: Prisma.KitProductWhereInput
  /**
   * Limit how many KitProducts to update.
   */
  limit?: number
}

/**
 * KitProduct updateManyAndReturn
 */
export type KitProductUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the KitProduct
   */
  select?: Prisma.KitProductSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the KitProduct
   */
  omit?: Prisma.KitProductOmit<ExtArgs> | null
  /**
   * The data used to update KitProducts.
   */
  data: Prisma.XOR<Prisma.KitProductUpdateManyMutationInput, Prisma.KitProductUncheckedUpdateManyInput>
  /**
   * Filter which KitProducts to update
   */
  where?: Prisma.KitProductWhereInput
  /**
   * Limit how many KitProducts to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.KitProductIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * KitProduct upsert
 */
export type KitProductUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the KitProduct
   */
  select?: Prisma.KitProductSelect<ExtArgs> | null
  /**
   * Omit specific fields from the KitProduct
   */
  omit?: Prisma.KitProductOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.KitProductInclude<ExtArgs> | null
  /**
   * The filter to search for the KitProduct to update in case it exists.
   */
  where: Prisma.KitProductWhereUniqueInput
  /**
   * In case the KitProduct found by the `where` argument doesn't exist, create a new KitProduct with this data.
   */
  create: Prisma.XOR<Prisma.KitProductCreateInput, Prisma.KitProductUncheckedCreateInput>
  /**
   * In case the KitProduct was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.KitProductUpdateInput, Prisma.KitProductUncheckedUpdateInput>
}

/**
 * KitProduct delete
 */
export type KitProductDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the KitProduct
   */
  select?: Prisma.KitProductSelect<ExtArgs> | null
  /**
   * Omit specific fields from the KitProduct
   */
  omit?: Prisma.KitProductOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.KitProductInclude<ExtArgs> | null
  /**
   * Filter which KitProduct to delete.
   */
  where: Prisma.KitProductWhereUniqueInput
}

/**
 * KitProduct deleteMany
 */
export type KitProductDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which KitProducts to delete
   */
  where?: Prisma.KitProductWhereInput
  /**
   * Limit how many KitProducts to delete.
   */
  limit?: number
}

/**
 * KitProduct without action
 */
export type KitProductDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the KitProduct
   */
  select?: Prisma.KitProductSelect<ExtArgs> | null
  /**
   * Omit specific fields from the KitProduct
   */
  omit?: Prisma.KitProductOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.KitProductInclude<ExtArgs> | null
}
